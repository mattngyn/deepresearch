---
title: "Environments API"
description: "API reference for building MCP environments with HUD"
icon: "cube"
---

## MCPServer

FastMCP wrapper with lifecycle management for Docker environments.

```python
from hud.server import MCPServer
```

### Constructor

```python
MCPServer(
    name: str,
    version: str = "0.1.0",
    **kwargs
)
```

<ParamField body="name" type="str" required>
  Environment name (e.g., "my-environment")
</ParamField>

<ParamField body="version" type="str" default="0.1.0">
  Environment version
</ParamField>

<ParamField body="**kwargs" type="dict">
  Additional arguments passed to FastMCP
</ParamField>

### Decorators

#### @server.tool()

Register an interaction tool (visible to agents):

```python
@server.tool()
def click(x: int, y: int) -> dict:
    """Click at coordinates"""
    # Implementation
    return {"success": True}
```

#### @server.setup_tool()

Register a setup tool (hidden from agents):

```python
@server.setup_tool()
def initialize_state(scenario: str = "default") -> dict:
    """Set up initial state"""
    # Reset and configure
    return {"message": f"Initialized {scenario}"}
```

#### @server.evaluate_tool()

Register an evaluation tool (hidden from agents):

```python
@server.evaluate_tool()
def check_success(threshold: float = 0.8) -> dict:
    """Evaluate task completion"""
    score = calculate_score()
    return {
        "reward": min(1.0, score / threshold),
        "details": f"Score: {score}"
    }
```

### Lifecycle Hooks

#### @server.initialize()

Called when MCP connection established:

```python
@server.initialize()
async def on_initialize():
    """Initialize environment resources"""
    print("Environment ready!", file=sys.stderr)
    # Set up resources
    await setup_database()
```

#### @server.shutdown()

Called on graceful shutdown:

```python
@server.shutdown()
async def on_shutdown():
    """Clean up resources"""
    print("Shutting down", file=sys.stderr)
    # Clean up
    await close_connections()
```

### Running the Server

```python
if __name__ == "__main__":
    server.run()
```

## MCP Clients

### MCPClient

Default client implementation using FastMCP:

```python
from hud.clients import MCPClient
```

#### Constructor

```python
MCPClient(mcp_config: dict[str, Any])
```

<ParamField body="mcp_config" type="dict" required>
  Environment connection configuration
</ParamField>

**Config formats:**

```python
# Docker
mcp_config = {
    "my-env": {
        "command": "docker",
        "args": ["run", "-i", "my-env:latest"],
        "env": {"DEBUG": "true"}
    }
}

# HTTP
mcp_config = {
    "remote": {
        "url": "https://mcp.example.com",
        "headers": {"Authorization": "Bearer token"}
    }
}

# Local command
mcp_config = {
    "local": {
        "command": "python",
        "args": ["server.py"]
    }
}
```

#### Methods

```python
async def initialize() -> None
async def list_tools() -> list[Tool]
async def call_tool(name: str, arguments: dict | None = None) -> CallToolResult
async def close() -> None
```

### Context Manager Usage

```python
async with MCPClient(mcp_config) as client:
    tools = await client.list_tools()
    result = await client.call_tool("click", {"x": 100, "y": 200})
```

## Tool Patterns

### Basic Tool

```python
@server.tool()
def greet(name: str) -> str:
    """Greet someone by name"""
    return f"Hello, {name}!"
```

### Tool with Validation

```python
@server.tool()
def move(direction: Literal["up", "down", "left", "right"]) -> dict:
    """Move in a direction"""
    if not is_valid_move(direction):
        return {
            "success": False,
            "error": "Invalid move",
            "valid_moves": get_valid_moves()
        }
    
    perform_move(direction)
    return {
        "success": True,
        "new_position": get_position(),
        "game_over": is_game_over()
    }
```

### Async Tool

```python
@server.tool()
async def fetch_data(url: str) -> dict:
    """Fetch data from URL"""
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as response:
            data = await response.json()
            return {
                "status": response.status,
                "data": data
            }
```

### Tool with Side Effects

```python
@server.tool()
def save_file(filename: str, content: str) -> dict:
    """Save content to file"""
    try:
        path = Path(f"/workspace/{filename}")
        path.write_text(content)
        return {
            "success": True,
            "path": str(path),
            "size": len(content)
        }
    except Exception as e:
        return {
            "success": False,
            "error": str(e)
        }
```

## Environment Structure

### Minimal Environment

```python
from hud.server import MCPServer

server = MCPServer("minimal-env")

# State
state = {"value": 0}

@server.tool()
def increment() -> dict:
    state["value"] += 1
    return {"value": state["value"]}

@server.tool()
def get_value() -> dict:
    return {"value": state["value"]}

@server.setup_tool()
def reset() -> dict:
    state["value"] = 0
    return {"message": "Reset"}

@server.evaluate_tool()
def check_target(target: int) -> dict:
    return {"reward": 1.0 if state["value"] >= target else 0.0}

if __name__ == "__main__":
    server.run()
```

### Complex Environment

```python
from hud.server import MCPServer
from .app import Application
from .evaluators import EvaluatorHub
from .setup import SetupHub

server = MCPServer("complex-env")
app = Application()
setup_hub = SetupHub(app)
eval_hub = EvaluatorHub(app)

# Register all tools from app
for tool_name, tool_func in app.get_tools().items():
    server.register_tool(tool_name)(tool_func)

# Register setup tools
for name, func in setup_hub.get_all().items():
    server.register_setup_tool(name)(func)

# Register evaluators
for name, func in eval_hub.get_all().items():
    server.register_evaluate_tool(name)(func)

@server.initialize()
async def startup():
    await app.initialize()
    logger.info("Application initialized")

@server.shutdown()
async def cleanup():
    await app.cleanup()
    logger.info("Application cleaned up")

if __name__ == "__main__":
    server.run()
```

## Registry Pattern

### Tool Registry

```python
class ToolRegistry:
    def __init__(self):
        self._tools = {}
    
    def register(self, name: str, func: Callable):
        """Register a tool function"""
        self._tools[name] = func
    
    def get(self, name: str) -> Callable:
        """Get tool by name"""
        if name not in self._tools:
            raise ValueError(f"Tool {name} not found")
        return self._tools[name]
    
    def list_tools(self) -> list[str]:
        """List all tool names"""
        return list(self._tools.keys())

# Usage
registry = ToolRegistry()
registry.register("click", click_function)
registry.register("type", type_function)

# Register with MCPServer
for name in registry.list_tools():
    server.register_tool(name)(registry.get(name))
```

## Error Handling

### Standard Error Response

```python
@server.tool()
def risky_operation(param: str) -> dict:
    try:
        result = perform_operation(param)
        return {
            "success": True,
            "result": result
        }
    except ValidationError as e:
        return {
            "success": False,
            "error": str(e),
            "error_type": "validation",
            "suggestion": "Check parameter format"
        }
    except TimeoutError:
        return {
            "success": False,
            "error": "Operation timed out",
            "error_type": "timeout",
            "recoverable": True
        }
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        return {
            "success": False,
            "error": "Internal error",
            "error_type": "internal",
            "recoverable": False
        }
```

## Performance Optimization

### Caching

```python
from functools import lru_cache

@server.tool()
@lru_cache(maxsize=100)
def expensive_query(query: str) -> dict:
    """Cached expensive operation"""
    result = perform_expensive_query(query)
    return {"result": result}
```

### Connection Pooling

```python
class ConnectionPool:
    def __init__(self, size: int = 10):
        self.pool = []
        for _ in range(size):
            self.pool.append(create_connection())
    
    async def get_connection(self):
        return self.pool.pop()
    
    def return_connection(self, conn):
        self.pool.append(conn)

pool = ConnectionPool()

@server.tool()
async def database_query(query: str) -> dict:
    conn = await pool.get_connection()
    try:
        result = await conn.execute(query)
        return {"result": result}
    finally:
        pool.return_connection(conn)
```

## Testing

### Unit Testing Tools

```python
import pytest
from src.server import server

def test_tool_registration():
    """Test tools are registered"""
    tools = server.list_tools()
    assert "click" in tools
    assert "type" in tools

@pytest.mark.asyncio
async def test_tool_execution():
    """Test tool executes correctly"""
    result = await server.execute_tool("greet", {"name": "Test"})
    assert result["content"] == "Hello, Test!"
```

### Integration Testing

```python
from hud.cli.debug import debug_mcp_stdio
from hud.cli.utils import CaptureLogger

async def test_environment():
    logger = CaptureLogger()
    command = ["python", "-m", "src.server"]
    
    phases = await debug_mcp_stdio(command, logger, max_phase=5)
    assert phases == 5  # All phases passed
```

## Next Steps

<Card title="Tasks API" icon="tasks" href="/reference/api/tasks">
  Task and dataset API reference
</Card>


